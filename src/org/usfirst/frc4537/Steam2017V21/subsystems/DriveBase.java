// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4537.Steam2017V21.subsystems;

import org.usfirst.frc4537.Steam2017V21.RobotMap;
import org.usfirst.frc4537.Steam2017V21.commands.*;
import com.ctre.CANTalon;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class DriveBase extends Subsystem {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final CANTalon cANTalonLeft1 = RobotMap.driveBaseCANTalonLeft1;
	private final CANTalon cANTalonRight1 = RobotMap.driveBaseCANTalonRight1;
	private final RobotDrive robotDrive = RobotMap.driveBaseRobotDrive;
	private final Encoder quadratureEncoderLeft = RobotMap.driveBaseQuadratureEncoderLeft;
	private final Encoder quadratureEncoderRight = RobotMap.driveBaseQuadratureEncoderRight;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final CANTalon cANTalonLeft2 = RobotMap.driveBaseCANTalonLeft2;
	private final CANTalon cANTalonRight2 = RobotMap.driveBaseCANTalonRight2;
	private final CANTalon cANTalonLeft3 = RobotMap.driveBaseCANTalonLeft3;
	private final CANTalon cANTalonRight3 = RobotMap.driveBaseCANTalonRight3;

	private double leftSpeed = 0;
	private double rightSpeed = 0;
	private double moveValue = 0;
	private double rotateValue = 0;
	private double moveSign = 1;
	private double rotateSign = 1;
	private boolean preserveSign = false;
	private double powerThingy = 2;    	
	//Speed limiter
	private double speedMultiplier = 0.5;

	//Acceleration limiter
	private double previousMoveValue = 0;
	private double previousRotateValue = 0;
	private double maxMoveAcceleration = 0.01;
	private double maxMoveDeceleration = 0.05;
	private double maxRotateAcceleration = 0.05;

	//private double leftCurrent = 0;
	//private double rightCurrent = 0;
	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new drive(0, 0));

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());

	}

	public void arcadeDrive(double speed, double turn){
		moveValue=speed;
		rotateValue=turn;

		moveSign = 1;
		if (moveValue < 0) {
			moveSign = -1;
		}
		rotateSign=1;
		if (rotateValue < 0) {
			rotateSign = -1;
		}
		if (powerThingy/2 == Math.floor(powerThingy/2)) { //Check if sign needs to be preserved
			preserveSign = true;
		}

		moveValue = Math.pow(moveValue, powerThingy);
		rotateValue = Math.pow(rotateValue, powerThingy);

		//Check acceleraton limitation
		moveValue = Math.abs(moveValue);
		rotateValue = Math.abs(rotateValue);

		if (moveValue > previousMoveValue + maxMoveAcceleration) {
			moveValue = previousMoveValue + maxMoveAcceleration;
		}

		if (moveValue < previousMoveValue - maxMoveDeceleration) {
			moveValue = previousMoveValue - maxMoveDeceleration;
		}

		if (rotateValue > previousRotateValue + maxRotateAcceleration) {
			rotateValue = previousRotateValue + maxRotateAcceleration;

		}

		previousMoveValue = moveValue;
		previousRotateValue = rotateValue;
		moveValue *= moveSign;
		rotateValue *= rotateSign;

		//Mathy arcadey stuffy
		if (moveValue > 0) {
			if (rotateValue > 0) {
				leftSpeed = moveValue - rotateValue;
				rightSpeed = Math.max(moveValue, rotateValue);
			}
			else {
				leftSpeed = Math.max(moveValue, -rotateValue);
				rightSpeed = moveValue + rotateValue;
			}
		}
		else {
			if (rotateValue > 0) {
				leftSpeed = -Math.max(-moveValue, rotateValue);
				rightSpeed = moveValue + rotateValue;
			}
			else {
				leftSpeed = moveValue - rotateValue;
				rightSpeed = -Math.max(-moveValue, -rotateValue);
			}
		}
		//dev throtteel
		//leftSpeed *= (1 - masterThrottel);
		//rightSpeed *= (1 - masterThrottel);

		//Apply speed limit
		leftSpeed *= speedMultiplier;
		rightSpeed *= speedMultiplier;

		//Set Maximum and Minimum
		leftSpeed = Math.max(leftSpeed, -1);
		leftSpeed = Math.min(leftSpeed, 1);
		rightSpeed = Math.max(rightSpeed, -1);
		rightSpeed = Math.min(rightSpeed, 1);

		//For all that is good in this world, DO NOT touch or breathe on these
		//the speed controllers must have the same amount otherwise it will die 
		//Left side
		this.cANTalonLeft1.set(leftSpeed);
		this.cANTalonLeft2.set(leftSpeed);
		this.cANTalonLeft3.set(leftSpeed);

		//Right Side
		this.cANTalonRight1.set(rightSpeed);
		this.cANTalonRight2.set(rightSpeed);
		this.cANTalonRight3.set(rightSpeed);

		//Calculate robot drive power draw
		//leftCurrent = pdp.getCurrent(0) + pdp.getCurrent(1) + pdp.getCurrent(2);
		//rightCurrent = pdp.getCurrent(13) + pdp.getCurrent(14) + pdp.getCurrent(15);

		Timer.delay(0.005); // wait for a motor update time
	}
}

