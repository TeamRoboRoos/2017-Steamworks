// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4537.Steam2017V21;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.CANTalon;
import edu.wpi.first.wpilibj.AnalogAccelerometer;
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Victor;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Encoder climberQuadratureEncoder;
    public static DigitalInput climberLimitSwitch;
    public static CANTalon climberCANTalon;
    public static CANTalon driveBaseCANTalonLeft1;
    public static CANTalon driveBaseCANTalonRight1;
    public static RobotDrive driveBaseRobotDrive;
    public static Encoder driveBaseQuadratureEncoderLeft;
    public static Encoder driveBaseQuadratureEncoderRight;
    public static CANTalon feederCANTalon2;
    public static CANTalon feederCANTalon1;
    public static Compressor gearsCompressor;
    public static DoubleSolenoid gearsDoubleSolenoid1;
    public static DoubleSolenoid gearsDoubleSolenoid2;
    public static CANTalon pickupCANTalon1;
    public static CANTalon pickupCANTalon2;
    public static Encoder shooterQuadratureEncoder1;
    public static CANTalon shooterCANTalon1;
    public static AnalogAccelerometer telemeteryAnalogAccelerometer;
    public static AnalogGyro telemeteryAnalogGyro;
    public static DigitalInput telemeteryPressure;
    public static PowerDistributionPanel telemeteryPowerDistributionPanel;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    //----------------------------------------------------------------
    //declare drive motors
    public static CANTalon driveBaseCANTalonLeft2;
    public static CANTalon driveBaseCANTalonRight2;
    public static CANTalon driveBaseCANTalonLeft3;
    public static CANTalon driveBaseCANTalonRight3;
    
    //Climber Motor
    public static Victor climberAuxMotor;
    
    //motor id
	private static final int MOTOR_1 = 1;
	private static final int MOTOR_2 = 2;
	private static final int MOTOR_3 = 3;
	private static final int MOTOR_4 = 4;
	private static final int MOTOR_5 = 5;
	private static final int MOTOR_6 = 6;
	
//---------------------------------------------------------------------------
	
    public static void init() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        climberQuadratureEncoder = new Encoder(5, 6, false, EncodingType.k4X);
        LiveWindow.addSensor("Climber", "Quadrature Encoder", climberQuadratureEncoder);
        climberQuadratureEncoder.setDistancePerPulse(1.0);
        climberQuadratureEncoder.setPIDSourceType(PIDSourceType.kRate);
        climberLimitSwitch = new DigitalInput(7);
        LiveWindow.addSensor("Climber", "Limit Switch", climberLimitSwitch);
        
        climberCANTalon = new CANTalon(0);
        LiveWindow.addActuator("Climber", "CAN Talon", climberCANTalon);
        
        driveBaseCANTalonLeft1 = new CANTalon(1);
        LiveWindow.addActuator("DriveBase", "CAN TalonLeft1", driveBaseCANTalonLeft1);
        
        driveBaseCANTalonRight1 = new CANTalon(2);
        LiveWindow.addActuator("DriveBase", "CAN TalonRight1", driveBaseCANTalonRight1);
        
        driveBaseRobotDrive = new RobotDrive(driveBaseCANTalonLeft1, driveBaseCANTalonRight1);
        
        driveBaseRobotDrive.setSafetyEnabled(true);
        driveBaseRobotDrive.setExpiration(0.1);
        driveBaseRobotDrive.setSensitivity(0.5);
        driveBaseRobotDrive.setMaxOutput(1.0);

        driveBaseRobotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        driveBaseQuadratureEncoderLeft = new Encoder(0, 1, false, EncodingType.k4X);
        LiveWindow.addSensor("DriveBase", "Quadrature EncoderLeft", driveBaseQuadratureEncoderLeft);
        driveBaseQuadratureEncoderLeft.setDistancePerPulse(1.0);
        driveBaseQuadratureEncoderLeft.setPIDSourceType(PIDSourceType.kRate);
        driveBaseQuadratureEncoderRight = new Encoder(2, 3, true, EncodingType.k4X);
        LiveWindow.addSensor("DriveBase", "Quadrature EncoderRight", driveBaseQuadratureEncoderRight);
        driveBaseQuadratureEncoderRight.setDistancePerPulse(1.0);
        driveBaseQuadratureEncoderRight.setPIDSourceType(PIDSourceType.kRate);
        feederCANTalon2 = new CANTalon(4);
        LiveWindow.addActuator("Feeder", "CAN Talon 2", feederCANTalon2);
        
        feederCANTalon1 = new CANTalon(3);
        LiveWindow.addActuator("Feeder", "CAN Talon 1", feederCANTalon1);
        
        gearsCompressor = new Compressor(0);
        
        
        gearsDoubleSolenoid1 = new DoubleSolenoid(0, 0, 1);
        LiveWindow.addActuator("Gears", "Double Solenoid 1", gearsDoubleSolenoid1);
        
        gearsDoubleSolenoid2 = new DoubleSolenoid(0, 2, 3);
        LiveWindow.addActuator("Gears", "Double Solenoid 2", gearsDoubleSolenoid2);
        
        pickupCANTalon1 = new CANTalon(5);
        LiveWindow.addActuator("Pickup", "CAN Talon 1", pickupCANTalon1);
        
        pickupCANTalon2 = new CANTalon(6);
        LiveWindow.addActuator("Pickup", "CAN Talon 2", pickupCANTalon2);
        
        shooterQuadratureEncoder1 = new Encoder(8, 9, false, EncodingType.k4X);
        LiveWindow.addSensor("Shooter", "Quadrature Encoder 1", shooterQuadratureEncoder1);
        shooterQuadratureEncoder1.setDistancePerPulse(1.0);
        shooterQuadratureEncoder1.setPIDSourceType(PIDSourceType.kRate);
        shooterCANTalon1 = new CANTalon(7);
        LiveWindow.addActuator("Shooter", "CAN Talon 1", shooterCANTalon1);
        
        telemeteryAnalogAccelerometer = new AnalogAccelerometer(0);
        LiveWindow.addSensor("Telemetery", "AnalogAccelerometer ", telemeteryAnalogAccelerometer);
        telemeteryAnalogAccelerometer.setSensitivity(0.0);
        telemeteryAnalogAccelerometer.setZero(2.5);
        telemeteryAnalogGyro = new AnalogGyro(1);
        LiveWindow.addSensor("Telemetery", "AnalogGyro", telemeteryAnalogGyro);
        telemeteryAnalogGyro.setSensitivity(0.007);
        telemeteryPressure = new DigitalInput(4);
        LiveWindow.addSensor("Telemetery", "Pressure", telemeteryPressure);
        
        telemeteryPowerDistributionPanel = new PowerDistributionPanel(0);
        LiveWindow.addSensor("Telemetery", "PowerDistributionPanel", telemeteryPowerDistributionPanel);
        

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        // ----------------------------------------------------------------------
        // instatniating the motors for drive
        
        //left motors
        RobotMap.driveBaseCANTalonLeft1 = new CANTalon(MOTOR_1); //frontLeftMotor
        RobotMap.driveBaseCANTalonLeft1.setExpiration(0.1);
        RobotMap.driveBaseCANTalonLeft1.setInverted(true);
        LiveWindow.addActuator("DriveBase", "CAN TalonLeft1", driveBaseCANTalonLeft1);
        
        RobotMap.driveBaseCANTalonLeft2 = new CANTalon(MOTOR_2); //middleLeftMotor
        RobotMap.driveBaseCANTalonLeft2.setExpiration(0.1);
        RobotMap.driveBaseCANTalonLeft2.setInverted(true);
        LiveWindow.addActuator("DriveBase", "CAN TalonLeft2", driveBaseCANTalonLeft2);
        
        RobotMap.driveBaseCANTalonLeft3 = new CANTalon(MOTOR_3); //rearLeftMotor
        RobotMap.driveBaseCANTalonLeft3.setExpiration(0.1);
        RobotMap.driveBaseCANTalonLeft3.setInverted(true);
        LiveWindow.addActuator("DriveBase", "CAN TalonLeft3", driveBaseCANTalonLeft3);
    	
    	//Right motors
        RobotMap.driveBaseCANTalonRight1 = new CANTalon(MOTOR_4); //frontRightMotor
        RobotMap.driveBaseCANTalonRight1.setExpiration(0.1);
        LiveWindow.addActuator("DriveBase", "CAN TalonRight1", driveBaseCANTalonRight1);
        
        RobotMap.driveBaseCANTalonRight2 = new CANTalon(MOTOR_5); //middleRightMotor
        RobotMap.driveBaseCANTalonRight2.setExpiration(0.1);
        LiveWindow.addActuator("DriveBase", "CAN TalonRight2", driveBaseCANTalonRight2);
        
        RobotMap.driveBaseCANTalonRight3 = new CANTalon(MOTOR_6); //rearRightMotor
        RobotMap.driveBaseCANTalonRight3.setExpiration(0.1);
        LiveWindow.addActuator("DriveBase", "CAN TalonRight3", driveBaseCANTalonRight3);
        
        RobotMap.climberAuxMotor = new Victor(0);
    }
}
